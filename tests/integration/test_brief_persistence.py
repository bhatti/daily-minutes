"""Integration tests for daily brief persistence.

Verifies that:
1. Briefs generated by brief_scheduler are saved to database
2. UI can load persisted briefs from database
3. Brief data is correctly serialized/deserialized
"""

import pytest
import asyncio
from datetime import datetime
from typing import Dict, Any

from src.services.brief_scheduler import get_brief_scheduler
from src.database.sqlite_manager import get_db_manager


@pytest.mark.asyncio
async def test_brief_is_saved_to_cache():
    """Test that generated briefs are saved to database cache.

    This test catches the bug where _store_brief() had a TODO comment
    and never actually saved briefs to the database.
    """
    # Setup
    db_manager = get_db_manager()
    await db_manager.initialize()

    # Clear existing brief cache
    await db_manager.set_cache('daily_brief_data', None)

    # Generate a brief using brief_scheduler
    brief_scheduler = get_brief_scheduler()
    await brief_scheduler._check_and_generate_brief()

    # Verify brief was saved to cache
    cached_brief = await db_manager.get_cache('daily_brief_data')

    assert cached_brief is not None, "Brief should be cached after generation"
    assert isinstance(cached_brief, dict), "Cached brief should be a dict"

    # Verify brief structure has required fields
    required_fields = ['summary', 'generated_at', 'emails_count', 'calendar_events_count',
                       'news_items_count', 'key_points', 'action_items']
    for field in required_fields:
        assert field in cached_brief, f"Brief should have '{field}' field"

    # Verify generated_at is recent
    generated_at = datetime.fromisoformat(cached_brief['generated_at'])
    assert generated_at is not None, "Brief should have generation timestamp"


@pytest.mark.asyncio
async def test_brief_timestamp_is_saved():
    """Test that brief generation timestamp is saved to settings."""
    # Setup
    db_manager = get_db_manager()
    await db_manager.initialize()

    # Generate brief
    brief_scheduler = get_brief_scheduler()
    await brief_scheduler._check_and_generate_brief()

    # Check timestamp was saved
    last_brief_time = await db_manager.get_setting('last_brief_generation')
    assert last_brief_time is not None, "Should have brief generation timestamp"

    # Parse and verify timestamp is recent (within last minute)
    brief_time = datetime.fromisoformat(last_brief_time)
    time_diff = (datetime.now() - brief_time).total_seconds()
    assert time_diff < 60, f"Timestamp should be recent (was {time_diff}s ago)"


@pytest.mark.asyncio
async def test_ui_can_load_persisted_brief():
    """Test that UI can load previously generated brief from cache.

    This simulates the flow:
    1. Preload generates brief -> saves to cache
    2. UI starts -> loads brief from cache
    """
    # Setup
    db_manager = get_db_manager()
    await db_manager.initialize()

    # Step 1: Generate and save brief (like preload does)
    brief_scheduler = get_brief_scheduler()
    await brief_scheduler._check_and_generate_brief()

    # Step 2: Load brief from cache (like UI startup does)
    cached_brief = await db_manager.get_cache('daily_brief_data')

    assert cached_brief is not None, "UI should be able to load cached brief"
    assert cached_brief['summary'], "Brief should have summary content"
    assert len(cached_brief['key_points']) > 0, "Brief should have key points"


@pytest.mark.asyncio
async def test_brief_serialization_preserves_data():
    """Test that brief data serialization doesn't lose fields.

    Ensures all important fields survive the save/load cycle.
    """
    # Setup
    db_manager = get_db_manager()
    await db_manager.initialize()

    # Generate brief
    brief_scheduler = get_brief_scheduler()
    await brief_scheduler._check_and_generate_brief()

    # Load it back
    cached_brief = await db_manager.get_cache('daily_brief_data')

    # Verify all expected fields are present with correct types
    expected_fields = {
        'summary': str,
        'generated_at': str,  # ISO format
        'emails_count': int,
        'calendar_events_count': int,
        'news_items_count': int,
        'key_points': list,
        'action_items': list,
        'weather_info': (dict, type(None)),  # Can be None
    }

    for field_name, expected_type in expected_fields.items():
        assert field_name in cached_brief, f"Brief missing field: {field_name}"
        if isinstance(expected_type, tuple):
            assert isinstance(cached_brief[field_name], expected_type), \
                f"{field_name} should be one of {expected_type}"
        else:
            assert isinstance(cached_brief[field_name], expected_type), \
                f"{field_name} should be {expected_type}"


@pytest.mark.asyncio
async def test_startup_service_loads_brief():
    """Test that startup_service loads brief data for UI.

    This is the complete integration test simulating real app startup.
    """
    # Setup
    db_manager = get_db_manager()
    await db_manager.initialize()

    # Generate brief
    brief_scheduler = get_brief_scheduler()
    await brief_scheduler._check_and_generate_brief()

    # Load via startup_service (how UI actually loads it)
    from src.services.startup_service import StartupService
    startup_service = StartupService(db_manager)
    startup_data = await startup_service.load_startup_data()

    # Verify brief is included in startup data
    assert 'daily_brief' in startup_data, "Startup data should include daily_brief"

    if startup_data['daily_brief']:  # May be None if generation conditions not met
        brief = startup_data['daily_brief']
        assert 'summary' in brief, "Brief should have summary"
        assert 'generated_at' in brief, "Brief should have timestamp"
