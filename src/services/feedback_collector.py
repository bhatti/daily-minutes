"""RLHF Feedback Collection Service.

This service collects user feedback and uses it to improve the AI's responses
through Reinforcement Learning from Human Feedback (RLHF).
"""

from typing import List, Dict, Any, Optional
from datetime import datetime
from enum import Enum
import json

from src.memory.retrieval import MemoryRetriever
from src.memory.models import Memory, MemoryType
from src.services.preference_tracker import PreferenceTracker, PreferenceCategory


class FeedbackType(Enum):
    """Types of feedback that can be collected."""
    DAILY_BRIEF = "daily_brief"
    NEWS_ARTICLE = "news_article"
    EMAIL_SUMMARY = "email_summary"
    CALENDAR_INSIGHT = "calendar_insight"
    AI_RESPONSE = "ai_response"


class FeedbackRating(Enum):
    """Rating values for feedback."""
    POSITIVE = "positive"  # User liked it (1.0)
    NEUTRAL = "neutral"    # User was neutral (0.5)
    NEGATIVE = "negative"  # User disliked it (0.0)


class FeedbackCollector:
    """Collect and analyze user feedback for RLHF.

    Features:
    - Collect structured feedback on various AI outputs
    - Analyze feedback patterns
    - Integrate with PreferenceTracker to learn preferences
    - Export feedback for analysis
    """

    def __init__(
        self,
        persist_directory: str = "./chroma_data",
        user_id: str = "default"
    ):
        """Initialize the feedback collector.

        Args:
            persist_directory: ChromaDB persistence directory
            user_id: User identifier for multi-user support
        """
        self.memory_retriever = MemoryRetriever(persist_directory=persist_directory)
        self.preference_tracker = PreferenceTracker(
            persist_directory=persist_directory,
            user_id=user_id
        )
        self.user_id = user_id

    async def collect_feedback(
        self,
        feedback_type: FeedbackType,
        rating: FeedbackRating,
        context: Dict[str, Any]
    ) -> None:
        """Collect user feedback.

        Args:
            feedback_type: Type of feedback being provided
            rating: User's rating (positive, neutral, negative)
            context: Additional context about the feedback
        """
        # Create feedback content for embedding
        content = f"""User Feedback
Type: {feedback_type.value}
Rating: {rating.value}
User: {self.user_id}
Timestamp: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
Context: {json.dumps(context)}
"""

        # Store as memory
        feedback_memory = Memory(
            id=f"feedback-{self.user_id}-{datetime.now().timestamp()}",
            type=MemoryType.CONVERSATION,  # Using CONVERSATION type for feedback
            content=content,
            metadata={
                "feedback_type": feedback_type.value,
                "rating": rating.value,
                "rating_value": self._rating_to_value(rating),
                "user_id": self.user_id,
                "context": context,
                "is_feedback": True,
            },
            embedding=None,  # Will be generated by memory store
        )

        await self.memory_retriever.store_memory(feedback_memory)

    def _rating_to_value(self, rating: FeedbackRating) -> float:
        """Convert rating to numeric value.

        Args:
            rating: Feedback rating

        Returns:
            Numeric value between 0.0 and 1.0
        """
        rating_map = {
            FeedbackRating.POSITIVE: 1.0,
            FeedbackRating.NEUTRAL: 0.5,
            FeedbackRating.NEGATIVE: 0.0,
        }
        return rating_map[rating]

    async def get_all_feedback(self) -> List[Memory]:
        """Get all feedback for the user.

        Returns:
            List of feedback memories
        """
        # Get all CONVERSATION memories (which includes feedback)
        all_conversations = await self.memory_retriever.memory_store.filter_by_type(
            MemoryType.CONVERSATION
        )

        # Filter for feedback only
        feedback_list = [
            m for m in all_conversations
            if m.metadata.get("is_feedback") is True
            and m.metadata.get("user_id") == self.user_id
        ]

        return feedback_list

    async def get_feedback_by_type(
        self,
        feedback_type: FeedbackType
    ) -> List[Memory]:
        """Get feedback filtered by type.

        Args:
            feedback_type: Type of feedback to retrieve

        Returns:
            List of feedback memories matching the type
        """
        all_feedback = await self.get_all_feedback()

        filtered = [
            fb for fb in all_feedback
            if fb.metadata.get("feedback_type") == feedback_type.value
        ]

        return filtered

    async def get_feedback_by_rating(
        self,
        rating: FeedbackRating
    ) -> List[Memory]:
        """Get feedback filtered by rating.

        Args:
            rating: Rating to filter by

        Returns:
            List of feedback memories matching the rating
        """
        all_feedback = await self.get_all_feedback()

        filtered = [
            fb for fb in all_feedback
            if fb.metadata.get("rating") == rating.value
        ]

        return filtered

    async def calculate_average_rating(
        self,
        feedback_type: FeedbackType
    ) -> float:
        """Calculate average rating for a feedback type.

        Args:
            feedback_type: Type of feedback to analyze

        Returns:
            Average rating value (0.0 to 1.0)
        """
        feedback_list = await self.get_feedback_by_type(feedback_type)

        if not feedback_list:
            return 0.5  # Neutral if no feedback

        total = sum(
            fb.metadata.get("rating_value", 0.5)
            for fb in feedback_list
        )

        return total / len(feedback_list)

    async def get_feedback_summary(self) -> Dict[str, Any]:
        """Get summary statistics of all feedback.

        Returns:
            Dictionary with feedback statistics
        """
        all_feedback = await self.get_all_feedback()

        # Count by type
        by_type = {}
        for fb_type in FeedbackType:
            type_feedback = [
                fb for fb in all_feedback
                if fb.metadata.get("feedback_type") == fb_type.value
            ]
            by_type[fb_type.value] = len(type_feedback)

        # Count by rating
        by_rating = {}
        for rating in FeedbackRating:
            rating_feedback = [
                fb for fb in all_feedback
                if fb.metadata.get("rating") == rating.value
            ]
            by_rating[rating.value] = len(rating_feedback)

        return {
            "total_feedback": len(all_feedback),
            "by_type": by_type,
            "by_rating": by_rating,
        }

    async def apply_feedback_learning(self) -> None:
        """Apply feedback to update user preferences.

        This analyzes recent feedback and updates the preference tracker
        to improve future AI responses.
        """
        all_feedback = await self.get_all_feedback()

        # Process news article feedback
        news_feedback = [
            fb for fb in all_feedback
            if fb.metadata.get("feedback_type") == FeedbackType.NEWS_ARTICLE.value
        ]

        for fb in news_feedback:
            context = fb.metadata.get("context", {})
            rating = fb.metadata.get("rating")

            if rating == FeedbackRating.POSITIVE.value:
                # Store positive preferences
                await self.preference_tracker.learn_from_feedback(
                    feedback_type="liked_article",
                    context=context
                )
            elif rating == FeedbackRating.NEGATIVE.value:
                # Store negative preferences
                await self.preference_tracker.learn_from_feedback(
                    feedback_type="disliked_article",
                    context=context
                )

        # Process daily brief feedback
        brief_feedback = [
            fb for fb in all_feedback
            if fb.metadata.get("feedback_type") == FeedbackType.DAILY_BRIEF.value
        ]

        # Learn formatting preferences from brief feedback
        for fb in brief_feedback:
            context = fb.metadata.get("context", {})
            rating = fb.metadata.get("rating")
            comment = context.get("comment", "")

            # Infer formatting preferences from comments
            if rating == FeedbackRating.POSITIVE.value:
                if "concise" in comment.lower() or "short" in comment.lower():
                    await self.preference_tracker.store_preference(
                        category=PreferenceCategory.FORMATTING,
                        key="brief_length",
                        value="concise",
                        confidence=0.7
                    )
                elif "detail" in comment.lower() or "verbose" in comment.lower():
                    await self.preference_tracker.store_preference(
                        category=PreferenceCategory.FORMATTING,
                        key="brief_length",
                        value="detailed",
                        confidence=0.7
                    )

    async def export_feedback(self) -> Dict[str, Any]:
        """Export all feedback as a dictionary.

        Returns:
            Dictionary of feedback organized by type
        """
        all_feedback = await self.get_all_feedback()

        export = {}
        for fb in all_feedback:
            fb_type = fb.metadata.get("feedback_type", "unknown")
            if fb_type not in export:
                export[fb_type] = []

            export[fb_type].append({
                "rating": fb.metadata.get("rating"),
                "rating_value": fb.metadata.get("rating_value"),
                "context": fb.metadata.get("context"),
                "timestamp": fb.timestamp.isoformat(),
            })

        return export


# Singleton instance
_feedback_collector: Optional[FeedbackCollector] = None


def get_feedback_collector(
    persist_directory: str = "./chroma_data",
    user_id: str = "default"
) -> FeedbackCollector:
    """Get singleton FeedbackCollector instance.

    Args:
        persist_directory: ChromaDB persistence directory
        user_id: User identifier

    Returns:
        FeedbackCollector instance
    """
    global _feedback_collector

    if _feedback_collector is None:
        _feedback_collector = FeedbackCollector(
            persist_directory=persist_directory,
            user_id=user_id
        )

    return _feedback_collector
